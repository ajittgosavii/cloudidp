#!/usr/bin/env python3
"""
Environment Generation and Management Tool
Generates Terraform configurations from templates for multi-environment deployments
"""

import os
import sys
import yaml
import json
import argparse
from pathlib import Path
from jinja2 import Template, Environment, FileSystemLoader
from datetime import datetime
from typing import Dict, Any, List


class EnvironmentGenerator:
    """Generate environment configurations from templates"""
    
    def __init__(self, template_dir: str = "templates", output_dir: str = "environments"):
        self.template_dir = Path(template_dir)
        self.output_dir = Path(output_dir)
        self.jinja_env = Environment(loader=FileSystemLoader(template_dir))
        
    def load_template(self, template_file: str) -> str:
        """Load YAML template file"""
        template_path = self.template_dir / template_file
        with open(template_path, 'r') as f:
            return f.read()
    
    def load_values(self, values_file: str) -> Dict[str, Any]:
        """Load values from YAML file"""
        with open(values_file, 'r') as f:
            return yaml.safe_load(f)
    
    def render_template(self, template_content: str, values: Dict[str, Any]) -> Dict[str, Any]:
        """Render Jinja2 template with values"""
        template = Template(template_content)
        rendered = template.render(**values)
        return yaml.safe_load(rendered)
    
    def generate_terraform_tfvars(self, config: Dict[str, Any], output_path: Path):
        """Generate terraform.tfvars file"""
        
        # Extract configuration
        network = config['infrastructure']['network']
        database = config['infrastructure']['database']
        compute = config['infrastructure']['compute']
        tags = config['tags']
        
        tfvars_content = f'''# Generated by Environment Generator
# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Environment: {config['metadata']['name']}

app_name           = "{config['metadata']['name']}"
environment        = "{config['metadata']['name']}"
vpc_cidr           = "{network['vpc_cidr']}"
availability_zones = {json.dumps(network['availability_zones'])}

database_config = {{
  engine            = "{database['engine']}"
  engine_version    = "{database['engine_version']}"
  instance_class    = "{database['instance_class']}"
  allocated_storage = {database['allocated_storage']}
  multi_az          = {str(database['multi_az']).lower()}
}}

compute_config = {{
  instance_type    = "{compute['instance_type']}"
  min_size         = {compute['min_size']}
  max_size         = {compute['max_size']}
  desired_capacity = {compute['desired_capacity']}
}}

tags = {{
'''
        
        for key, value in tags.items():
            tfvars_content += f'  {key:20s} = "{value}"\n'
        
        tfvars_content += '}\n'
        
        with open(output_path / 'terraform.tfvars', 'w') as f:
            f.write(tfvars_content)
    
    def generate_backend_tf(self, config: Dict[str, Any], output_path: Path):
        """Generate backend.tf file"""
        
        env_name = config['metadata']['name']
        
        backend_content = f'''# Backend configuration for {env_name}
terraform {{
  backend "s3" {{
    bucket         = "enterprise-terraform-state"
    key            = "environments/{env_name}/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-state-lock"
    
    # Assume role for state access
    role_arn = "arn:aws:iam::111111111111:role/TerraformStateAccess"
  }}
}}
'''
        
        with open(output_path / 'backend.tf', 'w') as f:
            f.write(backend_content)
    
    def generate_main_tf(self, config: Dict[str, Any], output_path: Path):
        """Generate main.tf file"""
        
        main_content = f'''# Main configuration for {config['metadata']['name']}
# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

terraform {{
  required_version = ">= 1.5.0"
  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}
}}

provider "aws" {{
  region = var.aws_region
  
  default_tags {{
    tags = var.tags
  }}
}}

# Import application module
module "application" {{
  source = "../../app-blueprints/web-application/infrastructure"

  app_name           = var.app_name
  environment        = var.environment
  vpc_cidr           = var.vpc_cidr
  availability_zones = var.availability_zones
  database_config    = var.database_config
  compute_config     = var.compute_config
  
  tags = var.tags
}}
'''
        
        with open(output_path / 'main.tf', 'w') as f:
            f.write(main_content)
    
    def generate_variables_tf(self, config: Dict[str, Any], output_path: Path):
        """Generate variables.tf file"""
        
        variables_content = '''# Input variables
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "app_name" {
  description = "Application name"
  type        = string
}

variable "environment" {
  description = "Environment name"
  type        = string
}

variable "vpc_cidr" {
  description = "VPC CIDR block"
  type        = string
}

variable "availability_zones" {
  description = "Availability zones"
  type        = list(string)
}

variable "database_config" {
  description = "Database configuration"
  type = object({
    engine            = string
    engine_version    = string
    instance_class    = string
    allocated_storage = number
    multi_az          = bool
  })
}

variable "compute_config" {
  description = "Compute configuration"
  type = object({
    instance_type    = string
    min_size         = number
    max_size         = number
    desired_capacity = number
  })
}

variable "tags" {
  description = "Resource tags"
  type        = map(string)
}
'''
        
        with open(output_path / 'variables.tf', 'w') as f:
            f.write(variables_content)
    
    def generate_outputs_tf(self, config: Dict[str, Any], output_path: Path):
        """Generate outputs.tf file"""
        
        outputs_content = '''# Outputs
output "vpc_id" {
  description = "VPC ID"
  value       = module.application.vpc_id
}

output "database_endpoint" {
  description = "Database endpoint"
  value       = module.application.database_endpoint
  sensitive   = true
}

output "application_url" {
  description = "Application URL"
  value       = "http://${module.application.alb_dns_name}"
}

output "alb_dns_name" {
  description = "ALB DNS name"
  value       = module.application.alb_dns_name
}
'''
        
        with open(output_path / 'outputs.tf', 'w') as f:
            f.write(outputs_content)
    
    def generate_readme(self, config: Dict[str, Any], output_path: Path):
        """Generate README.md file"""
        
        env_name = config['metadata']['name']
        
        readme_content = f'''# {env_name.upper()} Environment

## Description
{config['metadata']['description']}

**Created:** {config['metadata']['created_date']}  
**Created By:** {config['metadata']['created_by']}  
**Environment:** {env_name}

## Infrastructure Components

### Network
- VPC CIDR: {config['infrastructure']['network']['vpc_cidr']}
- Availability Zones: {', '.join(config['infrastructure']['network']['availability_zones'])}
- NAT Gateway: {'Enabled' if config['infrastructure']['network']['enable_nat_gateway'] else 'Disabled'}

### Database
- Engine: {config['infrastructure']['database']['engine']} {config['infrastructure']['database']['engine_version']}
- Instance Class: {config['infrastructure']['database']['instance_class']}
- Storage: {config['infrastructure']['database']['allocated_storage']} GB
- Multi-AZ: {'Yes' if config['infrastructure']['database']['multi_az'] else 'No'}
- Backup Retention: {config['infrastructure']['database']['backup_retention']} days

### Compute
- Instance Type: {config['infrastructure']['compute']['instance_type']}
- Min Size: {config['infrastructure']['compute']['min_size']}
- Max Size: {config['infrastructure']['compute']['max_size']}
- Desired Capacity: {config['infrastructure']['compute']['desired_capacity']}

## Security & Compliance
- Encryption: {'Enabled' if config['security']['encryption_enabled'] else 'Disabled'}
- Deletion Protection: {'Enabled' if config['security']['deletion_protection'] else 'Disabled'}
- Monitoring: {'Enabled' if config['security']['monitoring_enabled'] else 'Disabled'}
- Compliance Standards: {', '.join(config['compliance']['standards'])}

## Deployment

### Prerequisites
- Terraform >= 1.5.0
- AWS CLI configured
- Appropriate IAM permissions

### Initialize
```bash
terraform init
```

### Plan
```bash
terraform plan
```

### Apply
```bash
terraform apply
```

### Destroy
```bash
terraform destroy
```

## Maintenance
- Review and update configurations quarterly
- Monitor CloudWatch dashboards
- Review security findings weekly
- Update Terraform modules monthly

## Support
Contact: {config['metadata']['created_by']}

---
*Auto-generated by Environment Generator*
'''
        
        with open(output_path / 'README.md', 'w') as f:
            f.write(readme_content)
    
    def generate_environment(self, template_file: str, values_file: str, environment_name: str = None):
        """Generate complete environment configuration"""
        
        print(f"Loading template: {template_file}")
        template_content = self.load_template(template_file)
        
        print(f"Loading values: {values_file}")
        values = self.load_values(values_file)
        
        print("Rendering template...")
        config = self.render_template(template_content, values)
        
        # Use environment name from values if not specified
        if environment_name is None:
            environment_name = config['metadata']['name']
        
        # Create output directory
        env_path = self.output_dir / environment_name
        env_path.mkdir(parents=True, exist_ok=True)
        
        print(f"Generating files in: {env_path}")
        
        # Generate all files
        self.generate_terraform_tfvars(config, env_path)
        print("  âœ“ terraform.tfvars")
        
        self.generate_backend_tf(config, env_path)
        print("  âœ“ backend.tf")
        
        self.generate_main_tf(config, env_path)
        print("  âœ“ main.tf")
        
        self.generate_variables_tf(config, env_path)
        print("  âœ“ variables.tf")
        
        self.generate_outputs_tf(config, env_path)
        print("  âœ“ outputs.tf")
        
        self.generate_readme(config, env_path)
        print("  âœ“ README.md")
        
        print(f"\nâœ… Environment '{environment_name}' generated successfully!")
        print(f"ğŸ“ Location: {env_path.absolute()}")
        print(f"\nNext steps:")
        print(f"  1. cd {env_path}")
        print(f"  2. terraform init")
        print(f"  3. terraform plan")
        print(f"  4. terraform apply")
    
    def list_environments(self):
        """List all generated environments"""
        if not self.output_dir.exists():
            print("No environments found.")
            return
        
        environments = [d for d in self.output_dir.iterdir() if d.is_dir()]
        
        if not environments:
            print("No environments found.")
            return
        
        print("\nğŸ“‹ Generated Environments:")
        print("-" * 80)
        
        for env_dir in sorted(environments):
            readme_path = env_dir / 'README.md'
            if readme_path.exists():
                with open(readme_path, 'r') as f:
                    lines = f.readlines()
                    desc = next((line.strip() for line in lines if line.strip() and not line.startswith('#')), "")
                print(f"  â€¢ {env_dir.name:20s} - {desc}")
            else:
                print(f"  â€¢ {env_dir.name:20s}")
        
        print("-" * 80)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Generate Terraform environment configurations from templates'
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Generate command
    gen_parser = subparsers.add_parser('generate', help='Generate environment configuration')
    gen_parser.add_argument('--template', '-t', required=True, help='Template file')
    gen_parser.add_argument('--values', '-v', required=True, help='Values file')
    gen_parser.add_argument('--name', '-n', help='Environment name (optional)')
    gen_parser.add_argument('--template-dir', default='templates', help='Template directory')
    gen_parser.add_argument('--output-dir', default='environments', help='Output directory')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List generated environments')
    list_parser.add_argument('--output-dir', default='environments', help='Output directory')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    if args.command == 'generate':
        generator = EnvironmentGenerator(
            template_dir=args.template_dir,
            output_dir=args.output_dir
        )
        generator.generate_environment(args.template, args.values, args.name)
    
    elif args.command == 'list':
        generator = EnvironmentGenerator(output_dir=args.output_dir)
        generator.list_environments()


if __name__ == '__main__':
    main()
